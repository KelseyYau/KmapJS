export class Map {
    constructor(id) {
        this._drag = {
            flag: false,
            start: {
                x: 0,
                y: 0
            },
            end: {
                x: 0,
                y: 0
            }
        };
        this._geometries = [];
        this._canvas = document.getElementById(id);
        this._ctx = this._canvas.getContext("2d");
        this._onDoubleClick = this._onDoubleClick.bind(this);
        this._onMouseDown = this._onMouseDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseUp = this._onMouseUp.bind(this);
        this._onWheel = this._onWheel.bind(this);
        this._canvas.addEventListener("dblclick", this._onDoubleClick);
        this._canvas.addEventListener("mousedown", this._onMouseDown);
        this._canvas.addEventListener("mousemove", this._onMouseMove);
        this._canvas.addEventListener("mouseup", this._onMouseUp);
        this._canvas.addEventListener("wheel", this._onWheel);
    }
    addGeometry(geometry) {
        geometry.draw(this._ctx);
        this._geometries.push(geometry);
    }
    redraw() {
        this._ctx.save();
        this._ctx.setTransform(1, 0, 0, 1, 0, 0);
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._ctx.restore();
        this._geometries.forEach(geometry => geometry.draw(this._ctx));
    }
    clear() {
        this._ctx.setTransform(1, 0, 0, 1, 0, 0);
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
    }
    _onDoubleClick(event) {
        this._ctx.scale(2, 2);
        this.redraw();
    }
    _onMouseDown(event) {
        this._drag.flag = true;
        this._drag.start.x = event.x;
        this._drag.start.y = event.y;
    }
    _onMouseMove(event) {
    }
    _onMouseUp(event) {
        if (this._drag.flag) {
            this._drag.end.x = event.x;
            this._drag.end.y = event.y;
            const matrix = this._ctx.getTransform();
            this._ctx.translate((this._drag.end.x - this._drag.start.x) / matrix.a, (this._drag.end.y - this._drag.start.y) / matrix.b);
            this.redraw();
        }
        this._drag.flag = false;
    }
    _onWheel(event) {
        event.preventDefault();
        let scale = 1;
        const sensitivity = 100;
        const delta = event.deltaY / sensitivity;
        if (delta < 0) {
            // 鼠标放大
            scale *= delta * -2;
        }
        else {
            // 鼠标缩小
            scale /= delta * 2;
        }
        // 交互效果：鼠标当前位置 屏幕坐标不变情况下进行缩放  即 x2 = x1
        // 第一种方案，坐标系不变，变坐标的值来实现
        // 1. 将屏幕坐标 x1 转换成初始的坐标 x0 = (x1 - e1) * a1  初始的矩阵(1,0,0,1,0,0)   e1  a1 所代表是 距离尺度 和 比例尺度吗？
        //2.初始坐标x0 转成 现屏幕坐标x2  a2 * x0 + e2 = x2    e2 = x2 - a2 * x0  代入1式 e2 = x2 - a2 * (x1 - e1) / a1
        //3.已知scale = a2 / a1  故 e2 = x2 - scale * (x1 - e1)
        //4.另矩阵变换 a1 * e + e1 = e2
        //5.联立3和4  求得 e = (x2 - scale * (x1 - e1) - e1) / a1
        //PS: 第4点详解: matrix1 * matrix = matrix2；matrix1当前矩阵，matrix2为变换后的结果矩阵，matrix为变换矩阵；我们现在要求matrix的e，而根据矩阵计算，a1 * e + e1 = e2。其中a1是matrix1的a，e是matrix的e，e1是matrix1的e，e2是matrix2的e。
        const matrix = this._ctx.getTransform();
        const a1 = matrix.a, e1 = matrix.e, x1 = event.x, x2 = x1; //放大到中心点 x2 = this._canvas.width / 2
        const e = (x2 - scale * (x1 - e1) - e1) / a1;
        const d1 = matrix.d, f1 = matrix.f, y1 = event.y, y2 = y1; //放大到中心点 y2 = this._canvas.height / 2
        const f = (y2 - scale * (y1 - f1) - f1) / d1;
        this._ctx.transform(scale, 0, 0, scale, e, f);
        this.redraw();
    }
    destroy() {
        this._canvas.removeEventListener("dblclick", this._onDoubleClick);
        this._canvas.removeEventListener("mousedown", this._onMouseDown);
        this._canvas.removeEventListener("mousemove", this._onMouseMove);
        this._canvas.removeEventListener("mouseup", this._onMouseUp);
        this._canvas.removeEventListener("wheel", this._onWheel);
    }
}
